gc()

library(combinat)
library(igraph)
library(cplexAPI)
library(magrittr)
library(Matrix)
library(pracma)
library(slam)
library(tidyverse)

CPLEX_DIR = "/Applications/CPLEX_Studio201/cplex/bin/x86-64_osx/"
WORK_DIR  = "/Users/lchindelevitch/Downloads/NonPriority/Conjectures/RamseyNumbers"
setwd(WORK_DIR)
source("Ramsey/Utilities.R")

### TODO: For lower bounds consider implementing a version that looks for cyclic orientations too; the idea is to only constrain delta vectors which admit a bipartition!
### TODO: Explore the use of DFS instead of BFS in searching for the proof, so that as soon as a new tighter bound is found, it is immediately added to the constraints.
### TODO: Consider adding a global variable tracking subgraph relationships, to be created once at the start; it can be a sparse matrix or a tibble, depending on needs.
### TODO: Write an algorithm that spreads the bound density to support n-1 then tries to increase or keep the density in all future rounds; in order to do so it needs to
### keep a best bound tab on all the graphs, and for a lower bound t, add the corresponding lower bounds to all subgraphs with < t edges removed and all supergraphs, too

### This function iteratively constructs a minimal set of graphs sufficient for a proof
### that Ramsey(r, s) <= n; all of its other arguments are exactly as in iterateLPProof
findMinimalGraphSet = function(n = 9L, r = 3L, s = 4L, maxOrder = 6L, symRS = FALSE, shortProofs = TRUE, lowerOnly = FALSE, minAuto = NULL, eps = NA, strongCuts = FALSE,
                      extremeOnly = FALSE, treesOnly = FALSE, twoTreesOnly = FALSE, ETOnly = FALSE, partiteOnly = FALSE, completeOnly = FALSE, inds = NULL) {
  lastSolution = NULL
  endpoint = ifelse(r == s, 1, 2)
  inds = sort(setdiff(inds, (1:endpoint)))
  L = length(inds)
  dispensable = rep(NA, L)
  print(paste("There are", L, "indices to process"))
  while (any(is.na(dispensable))) {
    curInds = inds[which(is.na(dispensable) | !(dispensable))]
    testElement = inds[max(which(is.na(dispensable)))]
    altInds = setdiff(curInds, testElement)
    altRes  = iterateLPProof(n = n, r = r, s = s, maxOrder = maxOrder, symRS = symRS, shortProofs = shortProofs, lowerOnly = lowerOnly, minAuto = minAuto, eps = eps, inds = altInds,
              extremeOnly = extremeOnly, treesOnly = treesOnly, twoTreesOnly = twoTreesOnly, ETOnly = ETOnly, partiteOnly = partiteOnly, completeOnly = completeOnly, strongCuts = strongCuts)
    if (length(altRes) > 1) {
      print(paste("Removing", testElement, "leaves the contradiction valid"))
      lastSolution = altRes
      bestSolution = prepareBestProof(altRes[[4]], altRes[[3]], labels = outer(LETTERS, letters, paste0), r = r, s = s, plotGraphs = FALSE)
      newInds = altInds[sort(unique(setdiff(bestSolution$graph, (1:endpoint)))) - endpoint]
      dispensable[match(setdiff(curInds, newInds), inds)] = TRUE
    } else {
      dispensable[match(testElement, inds)] = FALSE
    }
  }
  output = list(inds = inds[which(!dispensable)], last = lastSolution)
  output
}

### This function tries to iteratively construct a proof that Ramsey(r,s) <= n.
### Search parameters (apply to the LPs and the corresponding proofs):
### maxOrder determines the largest order of the graphs that will be considered.
### If symRS = TRUE, only lower bounds are computed, the upper bounds being symmetric.
### If shortProofs = TRUE, only produces the shortened (not full) version of proofs.
### If lowerOnly = TRUE, no upper, bounds are computed (this is regardless of symRS).
### Graph selection parameters (Kr and Ks are considered essential and put 1st/2nd):
### If minAuto is not NULL, it is a lower bound on the automorphism group size.
### If eps is not NA, the current bound needs to be tightened by at least eps to count.
### If extremeOnly = TRUE, only keeps the graphs with sizes within 1 of min/max.
### If treesOnly = TRUE, only keeps the graphs with size equal to the order - 1.
### If twoTreesOnly = TRUE, only keeps the 2-trees (size equal to 2 * order - 3).
### If ETOnly = TRUE, only keeps the edge-transitive graphs from the OEIS reference.
### If partiteOnly = TRUE, only keeps the bipartite graphs as generated by nauty.
### If completeOnly = TRUE, only keeps the complete and complete bipartite graphs.
### If inds is not NULL, only keeps the non-essential graphs whose numbers are in inds.
### If strongCuts = TRUE, only keeps the bounds that are non-redundant in each LP.
iterateLPProof = function(n = 6L, r = 3L, s = r, maxOrder = round(2 * n / 3), symRS = (r == s), shortProofs = TRUE, lowerOnly = FALSE, minAuto = NULL, eps = NA,
                 extremeOnly = FALSE, treesOnly = FALSE, twoTreesOnly = FALSE, ETOnly = FALSE, partiteOnly = FALSE, completeOnly = FALSE, inds = NULL, strongCuts = TRUE) {
  allGraphs = list(as.vector(combn2(1:r)))
  if (r !=s ) {
    allGraphs %<>% c(list(as.vector(combn2(1:s))))
  }
  endpoint = ifelse(r == s, 1, 2)
  if (!completeOnly) {
    for (gorder in 2:maxOrder) {
      allGraphs %<>% c(getGraphs(gorder, extremeOnly = extremeOnly, treesOnly = treesOnly, twoTreesOnly = twoTreesOnly, ETOnly = ETOnly, partiteOnly = partiteOnly))
    }
    numAutos    = sapply(allGraphs, function(x) { as.integer(automorphisms(makeIgraph(x))$group_size) })
    graphTab    = tibble(size = sapply(allGraphs, length)/2, order = sapply(allGraphs, max), n_auto = numAutos, n_embed = factorial(order)/n_auto)
    repeatGraphs = graphTab %>%
      rowid_to_column(var = "index") %>%
      filter(order %in% c(r, s) & size == choose(order, 2) & index > endpoint) %>%
      pull(index)
    if (length(repeatGraphs) > 0) {
      allGraphs %<>% magrittr::extract(-repeatGraphs)
      graphTab  %<>% slice(-repeatGraphs)
    }
    goodGraphs   = (graphTab$order <= maxOrder)
    if (extremeOnly) { 
      goodGraphs = (goodGraphs & (graphTab$size <= graphTab$order) | graphTab$size >= (choose(graphTab$order, 2) - 1)) 
    }
    goodGraphs   = (goodGraphs & (graphTab$n_auto >= ifelse(is.null(minAuto), 1, minAuto))) 
    goodGraphs   = sort(unique(c(1:endpoint, which(goodGraphs))))
  } else {
    numAutos = unique(c(factorial(r), factorial(s)))
    for (gorder in 2:maxOrder) {
      if (gorder != r && gorder != s) {
        allGraphs %<>% c(list(as.vector(combn2(1:gorder))))
        numAutos  %<>% c(factorial(gorder))
      }
      for (left in ceiling(gorder/2):(gorder - 1)) {
        right  = gorder - left
        nextGraph = hcube(c(left, right))
        nextGraph[,2] %<>% add(left)
        allGraphs %<>% c(list(as.vector(nextGraph)))
        numAutos  %<>% c(factorial(left) * factorial(right) * ifelse(left == right, 2, 1))
      }
    }
    graphTab = tibble(size = sapply(allGraphs, length)/2, order = sapply(allGraphs, max), n_auto = numAutos, n_embed = factorial(order)/n_auto)
    goodGraphs = 1:nrow(graphTab)
  }
  if (!is.null(inds)) {
    inds = sort(unique(c(1:endpoint, inds)))
    goodGraphs %<>% magrittr::extract(inds)
  }
  allGraphs %<>% magrittr::extract(goodGraphs)
  graphTab  %<>% slice(goodGraphs) %>%
    rowid_to_column(var = "index")
  numGraphs = length(goodGraphs)
  allGraphAdj = vector("list", numGraphs)
  allGraphOrb = vector("list", numGraphs)
  boundTab = tibble(number = 1:2, support = c(r, s), graph = c(1, endpoint), direction = c("G", "L"), bound = c(1, choose(s, 2) - 1), round = 0L, subsumed = FALSE, size = choose(c(r, s), 2))
  boundIndex = 3
  proofs     = vector("list", n^2)
  curSupport = min(r, s) + 1
  curOrder   = curSupport
  curRound   = 0
  while (curOrder <= maxOrder) {
    curGraphTab = graphTab %>% 
      filter(order >= min(r, s) & order <= curOrder)
    print(paste("Exploring graphs on up to", curOrder, "vertices with support size", curSupport))
    boundTab = findAllSubsumed(allGraphs, boundTab, curGraphTab)
    dRange = boundTab %>% mutate(density = bound/size) %>% group_by(direction) %>% 
      mutate(opt = ifelse(direction == "G", max(density), min(density))) %>% slice(1) %>% ungroup
    print(paste("The edge density is currently between", dRange$opt[1], "and", dRange$opt[2]))
    if ((near(dRange$opt[1], dRange$opt[2]) && !near(choose(n,2) * dRange$opt[1], round(choose(n,2) * dRange$opt[1]))) || (dRange$opt[1] > dRange$opt[2])) {
      print(paste("Contradiction identified based on edge density!"))
      contradict = TRUE
      break
    }
    if (strongCuts && (dRange$opt[1] + 1 <= 2 * dRange$opt[2])) {
      eliminationResult = eliminateRedundantBounds(allGraphs, boundTab, curGraphTab, curSupport, allGraphAdj, allGraphOrb)
      boundTab = eliminationResult[[1]]
      allGraphAdj = eliminationResult[[2]]
      allGraphOrb = eliminationResult[[3]]
    }
    curRound     = curRound + 1
    finalResult  = tightenBounds(numVertices = curSupport, allGraphs = allGraphs, allGraphAdj = allGraphAdj, allGraphOrb = allGraphOrb, boundTab = boundTab, 
                   graphInfo = curGraphTab, nRound = paste0("R", r, "S", s, "I", curRound), symRS = symRS, shortProofs = shortProofs, eps = eps, lowerOnly = lowerOnly)
    fullResult  = finalResult[[1]]
    allGraphAdj = finalResult[[2]]
    allGraphOrb = finalResult[[3]]
    contradict = FALSE
    goodPieces = !sapply(fullResult, is.null)
    improved = any(goodPieces)
    if (improved) {
      fullResult = fullResult[goodPieces]
      for (ind in 1:length(fullResult)) {
        curResult = fullResult[[ind]]
        curGraph  = curResult$graph
        curSize = curGraphTab %>% 
          filter(index == curGraph) %>% 
          pull(size)
        if (!is.null(curResult$proofL)) {
          proofs[[boundIndex]] = curResult$proofL
          boundTab %<>% 
            bind_rows(tibble(number = boundIndex, support = curSupport, graph = curGraph, direction = "G", bound = curResult$boundL, round = curRound, 
                             subsumed = curResult$subsumedL, size = curSize))
          boundIndex = boundIndex + 1
        }
        if (!is.null(curResult$proofU)) {
          proofs[[boundIndex]] = curResult$proofU
          boundTab %<>% 
            bind_rows(tibble(number = boundIndex, support = curSupport, graph = curGraph, direction = "L", bound = curResult$boundU, round = curRound, 
                             subsumed = curResult$subsumedU, size = curSize))
          boundIndex = boundIndex + 1
        }
        contradict = (contradict || (curResult$boundL == curSize) || (!is.null(curResult$boundU) && (curResult$boundU == 0 || (curResult$boundL > curResult$boundU))))
      }
    } else {
      curSupport = curSupport + 1
      if (curOrder < maxOrder) {
        curOrder = curSupport
      } else {
        if (curSupport > n) {
          print("Not enough evidence for a contradiction!")
          return(FALSE)
        }
      }
    }
    if (contradict) {
      print("Found a contradiction!")
      break
    }
  }
  boundTab %<>%
    mutate(across(!direction, as.integer)) %>%
    group_by(round) %>%
    mutate(iter = cur_group_id()) %>%
    ungroup() %>%
    select(-round, -subsumed) %>%
    arrange(number)
  proofs = proofs[1:nrow(boundTab)]
  contradictions = NULL
  if (contradict) {
    contradictions = reconstructContradictions(proofs, boundTab, n)
  }
  output = list(proofs = proofs, boundTab = boundTab, graphs = allGraphs, contradictions = contradictions)
  output
}

### This function looks for and marks any bound subsumed by a single other bound in a graph set.
findAllSubsumed = function(allGraphs, boundTab, curGraphTab) {
  lowerBounds = identifySubsumedBounds(allGraphs, boundTab, curGraphTab, lower = TRUE)
  upperBounds = identifySubsumedBounds(allGraphs, boundTab, curGraphTab, lower = FALSE)
  boundTab    = bind_rows(lowerBounds, upperBounds)
  boundTab
}

### This function looks for and elmiminates any redundant bounds on a graph set.
eliminateRedundantBounds = function(allGraphs, boundTab, curGraphTab, support, allGraphAdj, allGraphOrb) {
  uGraphs     = boundTab %>% filter(!subsumed) %>% pull(graph) %>% unique %>% sort
  for (index in uGraphs) {
    if (is.null(allGraphAdj[[index]])) {
      if (is.null(allGraphOrb[[index]])) {
        allGraphOrb[[index]] = getOrbits(allGraphs[[index]])
      }
      allGraphAdj[[index]] = permuteGraph(allGraphs[[index]], allGraphOrb[[index]])
      gc()
    }
  }
  prep = prepareRamseyLP(support, allGraphs, allGraphAdj, allGraphOrb, boundTab, curGraphTab, sparse = TRUE)
  Map = prep$map[,1]
  uMap = sort(unique(Map))
  if (length(uMap) > 1) {
    auxMatrix   = createPositionMatrix(support, TRUE)
    numVars  = ncol(prep$mat)
    initObjective = rep(0, numVars)
    numConst = length(prep$dir)
    numNonZeros = tail(prep$mat@p,1)
    CN = paste0("X", 1:numVars)
    envir = cplexAPI::openEnvCPLEX()
    print(paste("There are", numConst, "constraints over", numVars, "variables"))
    for (ind in uMap) {
      curRow     = boundTab %>% filter(number == ind)
      curRange   = which(Map == ind)
      redMat = prep$mat
      redMat = redMat[-curRange, , drop = FALSE]
      redConst = numConst - length(curRange)
      redRhs = prep$rhs[-curRange]
      redDir = prep$dir[-curRange]
      redNonZeros = tail(redMat@p, 1)
      model = cplexAPI::initProbCPLEX(envir, pname = "Ramsey Polytope Optimisation")
      cplexAPI::setIntParmCPLEX(envir, cplexAPI::CPXPARAM_Preprocessing_Presolve, 0)
      cplexAPI::copyLpwNamesCPLEX(env = envir, lp = model, nCols = numVars, nRows = redConst, lpdir = CPX_MIN, objf = rep(0, numVars), rhs = redRhs, sense = redDir, 
      matbeg = redMat@p[1:numVars], matcnt = diff(redMat@p), matind = redMat@i, matval = rep(1, redNonZeros), lb = rep(0, numVars), ub = rep(1, numVars), cnames = CN)
      ### cplexAPI::writeProbCPLEX(envir, model, fname = paste0("Check", ind, ".lp"))
      curIndex   = curRow$graph
      curGraph   = allGraphs[[curIndex]]
      curOrder   = max(curGraph)
      curSize    = length(curGraph)/2
      curEdges   = auxMatrix[matrix(curGraph, ncol = 2)]
      curSense   = curRow$direction
      curBound   = curRow$bound
      curObjective = initObjective
      redCNames = cplexAPI::getColNameCPLEX(envir, model, 0, numVars - 1) %>% 
        str_remove("X") %>% 
        as.integer()
      curObjective[match(curEdges, redCNames)] = 1
      cplexAPI::chgObjCPLEX(envir, model, ncols = numVars, ind = 0:(numVars - 1), val = curObjective)
      cplexAPI::setObjDirCPLEX(envir, model, ifelse(curSense == "G", CPX_MIN, CPX_MAX))
      cplexAPI::dualoptCPLEX(envir, model)
      curObj = cplexAPI::solutionCPLEX(envir, model)$objval
      if (near(curObj, curBound) || (curSense == "G" && curObj > curBound) || (curSense == "L" && curObj < curBound)) {
        print(paste("Bound", ind, "is redundant and will be eliminated!"))
        pos = which(boundTab$number == ind)
        boundTab$subsumed[pos] = TRUE
      }
      cplexAPI::delProbCPLEX(envir, model)
    }
    cplexAPI::closeEnvCPLEX(envir)
  }
  output = list(boundTab = boundTab, allGraphAdj = prep$adj, allGraphOrb = allGraphOrb)
  output
}

### This function looks for tighter bounds on the number of red edges in a graph using currently available constraints.
### The Ramsey polytope is constructed over the specified order, numVertices; known bounds are provided via boundTab
### The output will contain information on all of the input graphs provided (allGraphs) that yield a non-trivial bound
### The allGraphAdj variable contains all the distinct permuted versions of each graph's adjacency list in the same order
### The allGraphOrb variable contains all the information about the orbits of each graph's automorphism group
### that also contain relevant information in graphInfo (in particular, whose indices are contained in its first column).
### If eps is specified (ie, not NA), the function looks for an improvement over the best existing bound by at least eps.
tightenBounds = function(numVertices, allGraphs, allGraphAdj, allGraphOrb, boundTab, graphInfo, nRound = 0, symRS = FALSE, shortProofs = TRUE, eps = NA, lowerOnly = FALSE) {
  prep = prepareRamseyLP(numVertices = numVertices, allGraphs = allGraphs, allGraphAdj = allGraphAdj, allGraphOrb = allGraphOrb, graphBounds = boundTab, 
                         graphInfo = graphInfo, sparse = TRUE)
  numVars  = ncol(prep$mat)
  numConst = length(prep$dir)
  numNonZeros = tail(prep$mat@p,1)
  CN = paste0("X", 1:numVars)
  ### Writing the model (with no objective function!) into an LP file with cplexAPI
  envir = cplexAPI::openEnvCPLEX()
  model = cplexAPI::initProbCPLEX(envir, pname = "Ramsey Polytope Optimisation")
  cplexAPI::copyLpwNamesCPLEX(env = envir, lp = model, nCols = numVars, nRows = numConst, lpdir = CPX_MIN, objf = rep(0, numVars), rhs = prep$rhs, sense = prep$dir, 
  matbeg = prep$mat@p[1:numVars], matcnt = diff(prep$mat@p), matind = prep$mat@i, matval = rep(1, numNonZeros), lb = rep(0, numVars), ub = rep(1, numVars), cnames = CN)
  fname  = paste0("TempFile", nRound, ".lp")
  cplexAPI::writeProbCPLEX(envir, model, fname = fname)
  cplexAPI::setIntParmCPLEX(envir, cplexAPI::CPXPARAM_Preprocessing_Presolve, 0)
  print(paste("There are", numConst, "constraints over", numVars, "variables"))
  L = nrow(graphInfo)
  output      = vector("list", L)
  auxMatrix   = createPositionMatrix(numVertices, symmetric = TRUE)
  print(paste("There are", L, "graphs to process"))
  initObjective = rep(0, numVars)
  for (ind in 1:L) {
    print(ind)
    curRow     = graphInfo %>% slice(ind)
    curIndex   = curRow$index
    curOrder   = curRow$order
    curGraph   = allGraphs[[curIndex]]
    curSize    = length(curGraph)/2
    curEdges   = auxMatrix[matrix(curGraph, ncol = 2)]
    prevLowerBound = max(c(0,       boundTab %>% filter(graph == curIndex & direction == "G") %>% pull(bound)))
    prevUpperBound = min(c(curSize, boundTab %>% filter(graph == curIndex & direction == "L") %>% pull(bound)))
    proofL  = NULL
    proofU  = NULL
    boundL  = NULL
    boundU  = NULL
    curResult = NULL
    curObjective = initObjective
    redCNames = cplexAPI::getColNameCPLEX(envir, model, 0, numVars - 1) %>% 
      str_remove("X") %>% 
      as.integer()
    curObjective[match(curEdges, redCNames)] = 1
    cplexAPI::chgObjCPLEX(envir, model, ncols = numVars, ind = 0:(numVars - 1), val = curObjective)
    numExtraConst = 0
    if (!is.na(eps)) {
      cplexAPI::setDblParmCPLEX(envir, cplexAPI::CPXPARAM_Simplex_Limits_LowerObj, prevLowerBound + eps)
    }
    if (is.null(allGraphOrb[[curIndex]])) {
      allGraphOrb[[curIndex]] = getOrbits(curGraph)
    }
    curGraphOrb = allGraphOrb[[curIndex]]
    extraOrbits = curGraphOrb$orbitsE
    if (curOrder < numVertices) {
      numExtraVerts = numVertices - curOrder
      extraVerts = (curOrder + 1):numVertices
      if (numExtraVerts > 1) {
        extraOutsideOrbits = as.vector(combn2(extraVerts))
        extraOrbits = c(extraOrbits, list(extraOutsideOrbits))
      }
      vOrbits = curGraphOrb$orbitsV
      extraInsideOutsideOrbits = lapply(vOrbits, function(x) { as.vector(as.matrix(expand.grid(x, extraVerts))) })
      extraOrbits = c(extraOrbits, extraInsideOutsideOrbits)
    }
    extraOrbits = lapply(extraOrbits, function(x) { auxMatrix[matrix(x, ncol = 2)]} )
    extraOrbits = extraOrbits[sapply(extraOrbits, length) > 1]
    if (length(extraOrbits) > 0) {
      numExtraConst = sum(sapply(extraOrbits, length)) - length(extraOrbits)
      extraIndices = lapply(extraOrbits, function(x) { y = rep(x, each = 2); y = y[-c(1, length(y))]; y })
      cplexAPI::addRowsCPLEX(envir, model, ncols = 0, nrows = numExtraConst, nnz = 2 * numExtraConst, sense = rep("E", numExtraConst), rhs = rep(0, numExtraConst),
                           matbeg = 2 * (0:(numExtraConst - 1)), matind = match(unlist(extraIndices), redCNames) - 1, matval = rep(c(1,-1), numExtraConst))
    }
    ### cplexAPI::writeProbCPLEX(envir, model, fname = fname)
    cplexAPI::dualoptCPLEX(envir, model)
    curSolution = cplexAPI::solutionCPLEX(envir, model)
    subsumedL = FALSE
    if (curSolution$lpstat == cplexAPI::CPX_STAT_OPTIMAL) {
      curObjL = curSolution$objval
      subsumedL = near(curObjL, round(curObjL))
      boundL  = as.integer(ifelse(subsumedL, round(curObjL), ceiling(curObjL)))
      if (boundL > prevLowerBound) {
        curDualsL  = curSolution$pi
        if (!(all(near(curDualsL, 0)))) {
          proofL   = constructProof(prep, curDualsL[1:numConst], lower = TRUE, shortProofs = shortProofs)
        }
      }
    }
    if (!is.na(eps)) {
      cplexAPI::setDblParmCPLEX(envir, cplexAPI::CPXPARAM_Simplex_Limits_LowerObj, 0)
    }
    subsumedU = FALSE
    if (symRS) {
      boundU = curSize - boundL
      proofU = proofL
      subsumedU = subsumedL
    } else {
      if (!lowerOnly) {
        cplexAPI::setObjDirCPLEX(envir, model, CPX_MAX)
        if (!is.na(eps)) {
          cplexAPI::setDblParmCPLEX(envir, cplexAPI::CPXPARAM_Simplex_Limits_UpperObj, prevUpperBound - eps)
        }
        cplexAPI::dualoptCPLEX(envir, model)
        altSolution = cplexAPI::solutionCPLEX(envir, model)
        if (curSolution$lpstat == cplexAPI::CPX_STAT_OPTIMAL) {
          curObjU = altSolution$objval
          subsumedU = near(curObjU, round(curObjU))
          boundU  = as.integer(ifelse(subsumedU, round(curObjU), floor(curObjU)))
          if (boundU < prevUpperBound) {
            curDualsU  = altSolution$pi
            if (!(all(near(curDualsU, 0)))) {
              proofU   = constructProof(prep, curDualsU[1:numConst], lower = FALSE, shortProofs = shortProofs)
            }
          }
        }
        if (!is.na(eps)) {
          cplexAPI::setDblParmCPLEX(envir, cplexAPI::CPXPARAM_Simplex_Limits_UpperObj, curSize)
        }
        cplexAPI::setObjDirCPLEX(envir, model, CPX_MIN)
      }
    }
    if (numExtraConst > 0) {
      cplexAPI::delRowsCPLEX(envir, model, numConst, numConst + numExtraConst - 1)
    }
    if (!is.null(proofL) || !is.null(proofU)) {
      curResult = list(graph = curIndex, proofL = proofL, proofU = proofU, boundL = boundL, boundU = boundU, subsumedL = subsumedL, subsumedU = subsumedU)
    }
    output[[ind]] = curResult
  }
  cplexAPI::delProbCPLEX(envir, model)
  cplexAPI::closeEnvCPLEX(envir)
  finalOutput = list(output = output, adj = prep$adj, orb = allGraphOrb)
  finalOutput
}

### This function constructs optimised proofs from the outputs of iterateLPProof
### If eps is non-NA, the 1 (-1) increment in objective value is replaced by eps.
### The objective is to identify proofs with a minimal number of dual variables.
optimiseProofs = function(output, eps = NA) {
  allContradictions = output[[4]]
  allGraphs = output[[3]]
  L = length(allGraphs)
  allGraphAdj = vector("list", L)
  allGraphOrb = vector("list", L)
  r = invertNumPairs(allContradictions[[1]]$size[1])
  s = invertNumPairs(allContradictions[[1]]$size[2])
  bestProof = prepareBestProof(allContradictions, allGraphs, r = r, s = s, fname = NULL, plotGraphs = TRUE) %>%
    mutate(subsumed = FALSE)
  M = nrow(bestProof)
  allProofs = vector("list", M)
  pos = 3
  maxIter = max(bestProof$step)
  numAutos = sapply(allGraphs, function(x) { as.integer(automorphisms(makeIgraph(x))$group_size) })
  graphTab = tibble(index = 1:L, size = sapply(allGraphs, length)/2, order = sapply(allGraphs, max), n_auto = numAutos, n_embed = factorial(order)/n_auto)
  for (ind in 2:maxIter) {
    prevBounds = bestProof %>%
      filter(step < ind) %>%
      group_by(graph, direction) %>%
      filter(step == max(step)) %>%
      ungroup()
    curBounds = bestProof %>%
      filter(step == ind)
    curSupport = curBounds$support[1]
    auxMatrix = createPositionMatrix(curSupport, symmetric = TRUE)
    prep = prepareRamseyLP(numVertices = curSupport, allGraphs = allGraphs, allGraphAdj = allGraphAdj, allGraphOrb = allGraphOrb, graphBounds = prevBounds, 
                           graphInfo = graphTab, sparse = TRUE)
    numVars  = ncol(prep$mat)
    numConst = length(prep$dir)
    numNonZeros = tail(prep$mat@p,1)
    CN = paste0("X", 1:numVars)
    initObjective = rep(0, numVars)
    envir = cplexAPI::openEnvCPLEX()
    model = cplexAPI::initProbCPLEX(envir, pname = "Ramsey Bound Optimisation")
    dualModel = cplexAPI::initProbCPLEX(envir, pname = "Ramsey Proof Optimisation")
    cplexAPI::copyLpwNamesCPLEX(env = envir, lp = model, nCols = numVars, nRows = numConst, lpdir = CPX_MIN, objf = rep(0, numVars), rhs = prep$rhs, sense = prep$dir, 
    matbeg = prep$mat@p[1:numVars], matcnt = diff(prep$mat@p), matind = prep$mat@i, matval = rep(1, numNonZeros), lb = rep(0, numVars), ub = rep(1, numVars), cnames = CN)
    fname  = paste0("ProofR", r, "S", s, "I", ind, ".lp")
    # cplexAPI::writeProbCPLEX(envir, model, fname = fname)
    cplexAPI::setIntParmCPLEX(envir, cplexAPI::CPXPARAM_Preprocessing_Presolve, 0)
    numBounds = nrow(curBounds)
    numVerts = invertNumPairs(numVars)
    allPairs = combn2(1:numVerts)
    for (index in 1:numBounds) {
      curBound = curBounds %>% slice(index)
      curIndex = curBound$graph
      curGraph = allGraphs[[curIndex]]
      curEdges = auxMatrix[matrix(curGraph, ncol = 2)]
      curSense = curBound$direction
      curTarget = curBound$bound
      redCNames = cplexAPI::getColNameCPLEX(envir, model, 0, numVars - 1) %>% 
        str_remove_all("X") %>% 
        as.integer()
      curObjective = initObjective
      curObjective[match(curEdges, redCNames)] = 1
      cplexAPI::chgObjCPLEX(envir, model, ncols = numVars, ind = 0:(numVars - 1), val = curObjective)
      cplexAPI::setObjDirCPLEX(envir, model, ifelse(curSense == "G", CPX_MIN, CPX_MAX))
      if (is.na(eps)) {
        cplexAPI::dualoptCPLEX(envir, model)
        origObj = cplexAPI::solutionCPLEX(envir, model)$objval
      }
      dualMPSFile = str_replace(fname, ".lp", "Dual.mps")
      dualWriteCPLEX(envir, model, fname = dualMPSFile)
      cplexAPI::readCopyProbCPLEX(envir, dualModel, fname = dualMPSFile)
      # cplexAPI::writeProbCPLEX(envir, dualModel, fname = str_replace(dualMPSFile, ".mps", ".lp"))
      extConst = cplexAPI::getNumColsCPLEX(envir, dualModel)
      stopifnot(extConst == numConst + numVars)
      newBound = ifelse(!is.na(eps), curTarget + ifelse(curSense == "G", -1, 1) * (1 - eps), origObj)
      origDualObj = cplexAPI::getObjCPLEX(envir, dualModel, 0, extConst - 1) * ifelse(curSense == "G", -1, 1)
      cplexAPI::addRowsCPLEX(envir, dualModel, nrows = 1, nnz = extConst, rhs = newBound, sense = ifelse(is.na(eps), curSense, "E"),
                             matbeg = 0, matind = 0:(extConst - 1), matval = origDualObj, ncols = 0, rnames = paste0("D", 0))
      newRange = rbind(1:extConst, extConst + (1:extConst), 1:extConst, extConst + (1:extConst))
      cplexAPI::newColsCPLEX(envir, dualModel, ncols = extConst, lb = rep(0, extConst), xctype = rep(cplexAPI::CPX_CONTINUOUS, extConst), cnames = c(paste0("Y", 1:numConst), paste0("Z", 1:numVars)))
      cplexAPI::addRowsCPLEX(envir, dualModel, nrows = 2 * extConst, nnz = 4 * extConst, rhs = rep(0, 2 * extConst), sense = rep("G", 2 * extConst), 
      matbeg = 2 * (0:(2 * extConst - 1)), matind = as.vector(newRange) - 1, matval = rep(c(-1, 1, 1, 1), extConst), ncols = 0, rnames = paste0("D", 1:(2 * extConst)))
      dualCNames = cplexAPI::getColNameCPLEX(envir, dualModel, 0, 2 * extConst - 1)
      newDualObj = rep(0, 2 * extConst)
      newDualObj[str_starts(dualCNames, "Y")] = 1 
      cplexAPI::chgObjCPLEX(envir, dualModel, ncols = 2 * extConst, ind = 0:(2 * extConst - 1), val = newDualObj)
      # cplexAPI::writeProbCPLEX(envir, dualModel, fname = str_replace(dualMPSFile, ".mps", ".lp"))
      cplexAPI::chgProbTypeCPLEX(envir, dualModel, ptype = cplexAPI::CPXPROB_LP)
      cplexAPI::primoptCPLEX(envir, dualModel)
      dualSolution = cplexAPI::solutionCPLEX(envir, dualModel)$x[1:numConst]
      sharpProof = constructProof(prep, dualSolution, lower = (curSense == "G"), shortProofs = FALSE)
      colnames(sharpProof) = c("coeff", paste0("X", allPairs[,1], ",", allPairs[,2]), "rhs", "bound")
      prevBounds %<>%
        select(number, label)
      sharpProof %<>%
        as_tibble() %>%
        left_join(prevBounds, by = join_by(bound == number))
      allProofs[[pos]] = sharpProof
      pos = pos + 1
    }
    cplexAPI::delProbCPLEX(envir, model)
    cplexAPI::delProbCPLEX(envir, dualModel)
    cplexAPI::closeEnvCPLEX(envir)
  }
  output = list(bestProof = bestProof, allProofs = allProofs)
  output
}

### This function traces the chain of proofs based on the LPs in a given directory
### The other inputs are r, s and n for which we are proving that Ramsey(r, s) >= n
### It returns the list of graphs used, the list of bounds (simplifyBounds = TRUE
### makes this list contain each bound's first occurrence, otherwise all of them), 
### and additional graph information: order, size and the number of automorphisms.
forensicTrace = function(Dir = "LPFilesForR3S4Auto6LowerOnly", r = 3, s = 3, n = 6, baseFilename = paste0("TempFileR", r, "S", s, "I"), simplifyBounds = FALSE) {
  initDir = getwd()
  setwd(Dir)
  LF = list.files(pattern = baseFilename)
  nC2 = choose(n, 2)
  allGraphs = matrix(NA, nrow = 0, ncol = nC2 * 2)
  graphPos = 1L
  boundTab = tibble()
  infoTab = tibble()
  envir = cplexAPI::openEnvCPLEX()
  model = cplexAPI::initProbCPLEX(envir, pname = "Ramsey Polytope")
  L = length(LF)
  print(paste("There are", L, "iterations to process"))
  curCount = 1L
  for (iter in 1:L) {
    curFile = paste0(baseFilename, iter, ".lp")
    cplexAPI::readCopyProbCPLEX(envir, model, fname = curFile)
    numVars = cplexAPI::getNumColsCPLEX(envir, model)
    numVerts = invertNumPairs(numVars)
    print(paste("Currently processing iteration", iter, "with", numVerts, "vertices in the support"))
    auxMatrix = createPositionMatrix(numVerts, symmetric = FALSE)
    curNames = cplexAPI::getColNameCPLEX(envir, model, 0, numVars - 1) %>%
      str_remove("X") %>%
      as.integer()
    curTotal = 0
    numConst = cplexAPI::getNumRowsCPLEX(envir, model)
    while (curTotal < numConst) {
      curRow = curNames[cplexAPI::getRowsCPLEX(envir, model, curTotal, curTotal)$matind + 1]
      curDir = cplexAPI::getSenseCPLEX(envir, model, curTotal, curTotal)
      curRhs = cplexAPI::getRhsCPLEX(envir, model, curTotal, curTotal)
      curGraph = which(matrix(auxMatrix %in% curRow, nrow = numVerts), arr.ind = TRUE) %>%
        as_tibble() %>%
        arrange(row, col) %>%
        as.matrix()
      allGraphs = rbind(allGraphs, as.vector(fillWithZeros(curGraph, nC2)))
      prevPos = which(duplicated(allGraphs, fromLast = TRUE))
      if (length(prevPos) == 0) {
        prevPos = graphPos
        curNumAutos = as.integer(automorphisms(makeIgraph(curGraph))$group_size)
        curInfo = tibble(graph = graphPos, order = max(curGraph), size = nrow(curGraph), n_auto = curNumAutos)
        infoTab %<>% bind_rows(curInfo)
        graphPos = graphPos + 1L
      } else {
        allGraphs = allGraphs[1:(graphPos - 1), , drop = FALSE] 
        curInfo = infoTab %>% slice(prevPos)
      }
      boundTab %<>% bind_rows(tibble(graph = prevPos, direction = curDir, bound = curRhs, round = iter, support = numVerts, number = curCount))
      curCount = curCount + 1L
      doubled = FALSE
      if (curTotal + 1 < numConst) {
        nextRow = curNames[cplexAPI::getRowsCPLEX(envir, model, curTotal + 1, curTotal + 1)$matind + 1]
        if (all(curRow == nextRow)) {
          doubled = TRUE
          nextDir = cplexAPI::getSenseCPLEX(envir, model, curTotal + 1, curTotal + 1)
          nextRhs = cplexAPI::getRhsCPLEX(envir, model, curTotal + 1, curTotal + 1)
          boundTab %<>% bind_rows(tibble(graph = prevPos, direction = nextDir, bound = nextRhs, round = iter, support = numVerts, number = curCount))
          curCount = curCount + 1L
        }
      }
      curNumConst = (factorial(numVerts) / (factorial(numVerts - curInfo$order) * curInfo$n_auto)) * (1 + doubled)
      curTotal = curTotal + curNumConst
    }
  }
  allGraphs = allGraphs[1:(graphPos - 1), , drop = FALSE]
  ### Adjustments to make the output compatible with downstream processing
  allGraphs %<>%
    split(1:nrow(.)) %>%
    lapply(function(x) { y = x[x != 0]; y })
  boundTab %<>%
    mutate(subsumed = FALSE, size = infoTab$size[graph])
  if (simplifyBounds) {
    boundTab = boundTab %>%
      group_by(graph, direction, bound) %>%
      filter(iter == min(iter)) %>%
      ungroup
  }
  infoTab %<>%
    rename(index = graph) %>%
    mutate(n_embed = factorial(order)/n_auto)
  setwd(initDir)
  output = list(allGraphs = allGraphs, boundTab = boundTab, graphInfo = infoTab)
  output
}
