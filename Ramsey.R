gc()

library(combinat)
library(igraph)
library(cplexAPI)
library(magrittr)
library(Matrix)
library(pracma)
library(slam)
library(tidyverse)

CPLEX_DIR = "/Applications/CPLEX_Studio201/cplex/bin/x86-64_osx/"
WORK_DIR  = "/Users/lchindelevitch/Downloads/NonPriority/Conjectures/RamseyNumbers"
setwd(WORK_DIR)
source("Ramsey/Utilities.R")

### TODO: For lower bounds consider implementing a version that looks for cyclic orientations too; the idea is to only constrain delta vectors which admit a bipartition!
### TODO: Explore the use of DFS instead of BFS in searching for the proof, so that as soon as a new tighter bound is found, it is immediately added to the constraints.

### This function iteratively constructs a minimal set of graphs sufficient for a proof
### that Ramsey(r, s) <= n; all of its other arguments are exactly as in iterateLPProof
findMinimalGraphSet = function(n = 9L, r = 3L, s = 4L, maxOrder = 6L, symRS = FALSE, shortProofs = TRUE, lowerOnly = FALSE, minAuto = NULL, eps = NA,
                               extremeOnly = FALSE, treesOnly = FALSE, twoTreesOnly = FALSE, ETOnly = FALSE, partiteOnly = FALSE, completeOnly = FALSE, inds = NULL) {
  lastSolution = NULL
  endpoint = ifelse(r == s, 1, 2)
  inds = sort(setdiff(inds, (1:endpoint)))
  L = length(inds)
  print(paste("There are", L, "indices to process"))
  pos = L
  while (pos >= 1) {
    print(pos)
    altInds = inds[-pos]
    altRes  = iterateLPProof(n = n, r = r, s = s, maxOrder = maxOrder, symRS = symRS, shortProofs = shortProofs, lowerOnly = lowerOnly, minAuto = minAuto, eps = eps, inds = altInds,
                             extremeOnly = extremeOnly, treesOnly = treesOnly, twoTreesOnly = twoTreesOnly, ETOnly = ETOnly, partiteOnly = partiteOnly, completeOnly = completeOnly)
    if (length(altRes) > 1) {
      print(paste("Removing", inds[pos], "leaves the contradiction valid"))
      lastSolution = altRes
      bestSolution = prepareBestProof(altRes[[4]], altRes[[3]], labels = c(LETTERS, letters), plotGraphs = FALSE)
      inds = altInds[sort(unique(setdiff(bestSolution$graph, (1:endpoint)))) - endpoint]
      pos = length(inds)
    } else {
      pos = pos - 1
    }
  }
  output = list(inds = inds, last = lastSolution)
  output
}

### This function tries to iteratively construct a proof that Ramsey(r,s) <= n.
### Search parameters (apply to the LPs and the corresponding proofs):
### maxOrder determines the largest order of the graphs that will be considered.
### If symRS = TRUE, only lower bounds are computed, the upper bounds being symmetric.
### If shortProofs = TRUE, only produces the shortened (not full) version of proofs.
### If lowerOnly = TRUE, no upper, bounds are computed (this is regardless of symRS).
### Graph selection parameters (Kr and Ks are considered essential and put 1st/2nd):
### If minAuto is not NULL, it is a lower bound on the automorphism group size.
### If eps is not NA, the current bound needs to be tightened by at least eps to count.
### If extremeOnly = TRUE, only keeps the graphs with sizes within 1 of min/max.
### If treesOnly = TRUE, only keeps the graphs with size equal to the order - 1.
### If twoTreesOnly = TRUE, only keeps the 2-trees (size equal to 2 * order - 3).
### If ETOnly = TRUE, only keeps the edge-transitive graphs from the OEIS reference.
### If partiteOnly = TRUE, only keeps the bipartite graphs as generated by nauty.
### If completeOnly = TRUE, only keeps the complete and complete bipartite graphs.
### If inds is not NULL, only keeps the non-essential graphs whose numbers are in inds.
iterateLPProof = function(n = 6L, r = 3L, s = r, maxOrder = round(2 * n / 3), symRS = (r == s), shortProofs = TRUE, lowerOnly = FALSE, minAuto = NULL, eps = NA,
                          extremeOnly = FALSE, treesOnly = FALSE, twoTreesOnly = FALSE, ETOnly = FALSE, partiteOnly = FALSE, completeOnly = FALSE, inds = NULL) {
  allGraphs = list(as.vector(combn2(1:r)))
  if (r !=s ) {
    allGraphs %<>% c(list(as.vector(combn2(1:s))))
  }
  endpoint = ifelse(r == s, 1, 2)
  if (!completeOnly) {
    for (gsize in 2:maxOrder) {
      allGraphs %<>% c(getGraphs(gsize, extremeOnly = extremeOnly, treesOnly = treesOnly, twoTreesOnly = twoTreesOnly, ETOnly = ETOnly, partiteOnly = partiteOnly))
    }
    numAutos    = sapply(allGraphs, function(x) { as.integer(automorphisms(makeIgraph(x))$group_size) })
    graphTab    = tibble(size = sapply(allGraphs, length)/2, order = sapply(allGraphs, max), n_auto = numAutos, n_embed = factorial(order)/n_auto)
    repeatGraphs = graphTab %>%
      rowid_to_column(var = "index") %>%
      filter(order %in% c(r, s) & size == choose(order, 2) & index > endpoint) %>%
      pull(index)
    if (length(repeatGraphs) > 0) {
      allGraphs %<>% magrittr::extract(-repeatGraphs)
      graphTab  %<>% slice(-repeatGraphs)
    }
    goodGraphs   = (graphTab$order <= maxOrder)
    if (extremeOnly) { 
      goodGraphs = (goodGraphs & (graphTab$size <= graphTab$order) | graphTab$size >= (choose(graphTab$order, 2) - 1)) 
    }
    goodGraphs   = (goodGraphs & (graphTab$n_auto >= ifelse(is.null(minAuto), 1, minAuto))) 
    goodGraphs   = sort(unique(c(1:endpoint, which(goodGraphs))))
  } else {
    numAutos = unique(c(factorial(r), factorial(s)))
    for (gsize in 2:maxOrder) {
      if (gsize != r && gsize != s) {
        allGraphs %<>% c(list(as.vector(combn2(1:gsize))))
        numAutos  %<>% c(factorial(gsize))
      }
      for (left in ceiling(gsize/2):(gsize - 1)) {
        right  = gsize - left
        nextGraph = hcube(c(left, right))
        nextGraph[,2] %<>% add(left)
        allGraphs %<>% c(list(as.vector(nextGraph)))
        numAutos  %<>% c(factorial(left) * factorial(right) * ifelse(left == right, 2, 1))
      }
    }
    graphTab = tibble(size = sapply(allGraphs, length)/2, order = sapply(allGraphs, max), n_auto = numAutos, n_embed = factorial(order)/n_auto)
    goodGraphs = 1:nrow(graphTab)
  }
  if (!is.null(inds)) {
    inds = sort(unique(c(1:endpoint, inds)))
    goodGraphs %<>% magrittr::extract(inds)
  }
  allGraphs %<>% magrittr::extract(goodGraphs)
  graphTab  %<>% slice(goodGraphs) %>%
    rowid_to_column(var = "index")
  numGraphs = length(goodGraphs)
  allGraphAdj = vector("list", numGraphs)
  allGraphOrb = vector("list", numGraphs)
  boundTab = tibble(number = 1:2, support = c(r, s), graph = c(1, endpoint), direction = c("G", "L"), bound = c(1, choose(s, 2) - 1), round = 0L, subsumed = FALSE, size = choose(c(r, s), 2))
  boundIndex = 3
  proofs     = vector("list", n^2)
  curSupport = min(r, s) + 1
  curOrder   = curSupport
  curRound   = 0
  while (curOrder <= maxOrder) {
    curGraphTab = graphTab %>% 
      filter(order >= min(r, s) & order <= curOrder)
    print(paste("Exploring graphs on up to", curOrder, "vertices with support size", curSupport))
    boundTab = eliminateRedundantBounds(allGraphs, boundTab, curGraphTab, curSupport)
    ### lowerBounds = identifySubsumedBounds(allGraphs, boundTab, curGraphTab, lower = TRUE)
    ### upperBounds = identifySubsumedBounds(allGraphs, boundTab, curGraphTab, lower = FALSE)
    ### boundTab    = bind_rows(lowerBounds, upperBounds)
    curRound    = curRound + 1
    finalResult  = tightenBounds(numVertices = curSupport, allGraphs = allGraphs, allGraphAdj = allGraphAdj, allGraphOrb = allGraphOrb, boundTab = boundTab, 
                   graphInfo = curGraphTab, nRound = paste0("R", r, "S", s, "I", curRound), symRS = symRS, shortProofs = shortProofs, eps = eps, lowerOnly = lowerOnly)
    fullResult  = finalResult[[1]]
    allGraphAdj = finalResult[[2]]
    allGraphOrb = finalResult[[3]]
    contradict = FALSE
    goodPieces = !sapply(fullResult, is.null)
    improved = any(goodPieces)
    if (improved) {
      fullResult = fullResult[goodPieces]
      for (ind in 1:length(fullResult)) {
        curResult = fullResult[[ind]]
        curGraph  = curResult$graph
        curSize = curGraphTab %>% 
          filter(index == curGraph) %>% 
          pull(size)
        if (!is.null(curResult$proofL)) {
          proofs[[boundIndex]] = curResult$proofL
          boundTab %<>% 
            bind_rows(tibble(number = boundIndex, support = curSupport, graph = curGraph, direction = "G", bound = curResult$boundL, round = curRound, subsumed = FALSE, size = curSize))
          boundIndex = boundIndex + 1
        }
        if (!is.null(curResult$proofU)) {
          proofs[[boundIndex]] = curResult$proofU
          boundTab %<>% 
            bind_rows(tibble(number = boundIndex, support = curSupport, graph = curGraph, direction = "L", bound = curResult$boundU, round = curRound, subsumed = FALSE, size = curSize))
          boundIndex = boundIndex + 1
        }
        contradict = (contradict || (curResult$boundL == curSize) || (!is.null(curResult$boundU) && (curResult$boundU == 0 || (curResult$boundL > curResult$boundU))))
      }
    } else {
      curSupport = curSupport + 1
      if (curOrder < maxOrder) {
        curOrder = curSupport
      } else {
        if (curSupport > n) {
          print("Not enough evidence for a contradiction!")
          return(FALSE)
        }
      }
    }
    if (contradict) {
      print("Found a contradiction!")
      break
    }
  }
  boundTab %<>%
    mutate(across(!direction, as.integer)) %>%
    group_by(round) %>%
    mutate(iter = cur_group_id()) %>%
    ungroup() %>%
    select(-round, -subsumed) %>%
    arrange(number)
  proofs = proofs[1:nrow(boundTab)]
  contradictions = NULL
  if (contradict) {
    contradictions = reconstructContradictions(proofs, boundTab)
  }
  firstGraphs = lapply(allGraphs, function(x) { matrix(x, ncol = 2) })
  output = list(proofs = proofs, boundTab = boundTab, graphs = firstGraphs, contradictions = contradictions)
  output
}

### This function looks for and elmiminates any redundant bounds on a graph set.
eliminateRedundantBounds = function(allGraphs, boundTab, curGraphTab, support) {
  if (is.matrix(allGraphs)) {
    allGraphs %<>%
      split(1:nrow(.)) %>%
      lapply(function(x) { y = x[x != 0]; y })
  }
  if ("graph" %in% colnames(curGraphTab)) {
    curGraphTab %<>%
      rename(index = graph)
  }
  lowerBounds = identifySubsumedBounds(allGraphs, boundTab, curGraphTab, lower = TRUE)
  upperBounds = identifySubsumedBounds(allGraphs, boundTab, curGraphTab, lower = FALSE)
  boundTab    = bind_rows(lowerBounds, upperBounds)
  reducedTab  = boundTab %>%
    inner_join(curGraphTab, by = join_by(graph == index, size == size)) %>%
    mutate(n_embed = factorial(order)/n_auto, numConst = choose(support, order) * n_embed) %>%
    arrange(numConst, order, size) %>%
    select(-order, -n_auto)
  ### TODO: eventually, we must pass the actual adj and orb objects to this function
  allGraphOrb = lapply(allGraphs, getOrbits)
  allGraphAdj = vector("list", length(allGraphs))
  auxMatrix   = createPositionMatrix(support, TRUE)
  initObjective = rep(0, choose(support, 2))
  prep = prepareRamseyLP(support, allGraphs, allGraphAdj, allGraphOrb, reducedTab, curGraphTab, sparse = TRUE)
  allGraphAdj = prep$adj
  Map = prep$map[,1]
  numVars  = ncol(prep$mat)
  numConst = length(prep$dir)
  numNonZeros = tail(prep$mat@p,1)
  CN = paste0("X", 1:numVars)
  envir = cplexAPI::openEnvCPLEX()
  model = cplexAPI::initProbCPLEX(envir, pname = "Ramsey Polytope Optimisation")
  cplexAPI::setIntParmCPLEX(envir, cplexAPI::CPXPARAM_Preprocessing_Presolve, 0)
  print(paste("There are", numConst, "constraints over", numVars, "variables"))
  for (ind in 1:nrow(reducedTab)) {
    print(paste("Processing constraint", ind))
    cplexAPI::copyLpwNamesCPLEX(env = envir, lp = model, nCols = numVars, nRows = numConst, lpdir = CPX_MIN, objf = rep(0, numVars), rhs = prep$rhs, sense = prep$dir, 
    matbeg = prep$mat@p[1:numVars], matcnt = diff(prep$mat@p), matind = prep$mat@i, matval = rep(1, numNonZeros), lb = rep(0, numVars), ub = rep(1, numVars), cnames = CN)
    curRow     = reducedTab %>% slice(ind)
    curNumber  = curRow$number
    curRange   = range(which(Map == curNumber))
    cplexAPI::delRowsCPLEX(envir, model, curRange[1] - 1, curRange[2] - 1)
    curIndex   = curRow$graph
    curGraph   = allGraphs[[curIndex]]
    curOrder   = max(curGraph)
    curSize    = length(curGraph)/2
    curEdges   = auxMatrix[matrix(curGraph, ncol = 2)]
    curSense   = curRow$direction
    curBound   = curRow$bound
    curObjective = initObjective
    redCNames = cplexAPI::getColNameCPLEX(envir, model, 0, numVars - 1) %>% 
      str_remove("X") %>% 
      as.integer()
    curObjective[match(curEdges, redCNames)] = 1
    cplexAPI::chgObjCPLEX(envir, model, ncols = numVars, ind = 0:(numVars - 1), val = curObjective)
    cplexAPI::setObjDirCPLEX(envir, model, ifelse(curSense == "G", CPX_MIN, CPX_MAX))
    cplexAPI::dualoptCPLEX(envir, model)
    curObj = cplexAPI::solutionCPLEX(envir, model)$objval
    if (near(curObj, curBound) || (curSense == "G" && curObj > curBound) || (curSense == "L" && curObj < curBound)) {
      print("This constraint is redundant and will be eliminated!")
      reducedTab$subsumed[ind] = TRUE
    }
  }
  boundTab = reducedTab %>%
    select()
  boundTab
}

### This function looks for tighter bounds on the number of red edges in a graph using currently available constraints.
### The Ramsey polytope is constructed over the specified order, numVertices; known bounds are provided via boundTab
### The output will contain information on all of the input graphs provided (allGraphs) that yield a non-trivial bound
### The allGraphAdj variable contains all the distinct permuted versions of each graph's adjacency list in the same order
### The allGraphOrb variable contains all the information about the orbits of each graph's automorphism group
### that also contain relevant information in graphInfo (in particular, whose indices are contained in its first column).
### If eps is specified (ie, not NA), the function looks for an improvement over the best existing bound by at least eps.
tightenBounds = function(numVertices, allGraphs, allGraphAdj, allGraphOrb, boundTab, graphInfo, nRound = 0, symRS = FALSE, shortProofs = TRUE, eps = NA, lowerOnly = FALSE) {
  prep = prepareRamseyLP(numVertices = numVertices, allGraphs = allGraphs, allGraphAdj = allGraphAdj, allGraphOrb = allGraphOrb, graphBounds = boundTab, 
                         graphInfo = graphInfo, sparse = TRUE)
  numVars  = ncol(prep$mat)
  numConst = length(prep$dir)
  numNonZeros = tail(prep$mat@p,1)
  CN = paste0("X", 1:numVars)
  ### Writing the model (with no objective function!) into an LP file with cplexAPI
  envir = cplexAPI::openEnvCPLEX()
  model = cplexAPI::initProbCPLEX(envir, pname = "Ramsey Polytope Optimisation")
  cplexAPI::copyLpwNamesCPLEX(env = envir, lp = model, nCols = numVars, nRows = numConst, lpdir = CPX_MIN, objf = rep(0, numVars), rhs = prep$rhs, sense = prep$dir, 
  matbeg = prep$mat@p[1:numVars], matcnt = diff(prep$mat@p), matind = prep$mat@i, matval = rep(1, numNonZeros), lb = rep(0, numVars), ub = rep(1, numVars), cnames = CN)
  fname  = paste0("TempFile", nRound, ".lp")
  cplexAPI::writeProbCPLEX(envir, model, fname = fname)
  cplexAPI::setIntParmCPLEX(envir, cplexAPI::CPXPARAM_Preprocessing_Presolve, 0)
  print(paste("There are", numConst, "constraints over", numVars, "variables"))
  L = nrow(graphInfo)
  output      = vector("list", L)
  auxMatrix   = createPositionMatrix(numVertices, symmetric = TRUE)
  print(paste("There are", L, "graphs to process"))
  initObjective = rep(0, numVars)
  for (ind in 1:L) {
    print(ind)
    curRow     = graphInfo %>% slice(ind)
    curIndex   = curRow$index
    curOrder   = curRow$order
    curGraph   = allGraphs[[curIndex]]
    curSize    = length(curGraph)/2
    curEdges   = auxMatrix[matrix(curGraph, ncol = 2)]
    prevLowerBound = max(c(0,       boundTab %>% filter(graph == curIndex & direction == "G") %>% pull(bound)))
    prevUpperBound = min(c(curSize, boundTab %>% filter(graph == curIndex & direction == "L") %>% pull(bound)))
    proofL  = NULL
    proofU  = NULL
    boundL  = NULL
    boundU  = NULL
    curResult = NULL
    curObjective = initObjective
    redCNames = cplexAPI::getColNameCPLEX(envir, model, 0, numVars - 1) %>% 
      str_remove("X") %>% 
      as.integer()
    curObjective[match(curEdges, redCNames)] = 1
    cplexAPI::chgObjCPLEX(envir, model, ncols = numVars, ind = 0:(numVars - 1), val = curObjective)
    numExtraConst = 0
    if (!is.na(eps)) {
      cplexAPI::setDblParmCPLEX(envir, cplexAPI::CPXPARAM_Simplex_Limits_LowerObj, prevLowerBound + eps)
    }
    if (is.null(allGraphOrb[[curIndex]])) {
      allGraphOrb[[curIndex]] = getOrbits(curGraph)
    }
    curGraphOrb = allGraphOrb[[curIndex]]
    extraOrbits = curGraphOrb$orbitsE
    if (curOrder < numVertices) {
      numExtraVerts = numVertices - curOrder
      extraVerts = (curOrder + 1):numVertices
      if (numExtraVerts > 1) {
        extraOutsideOrbits = as.vector(combn2(extraVerts))
        extraOrbits = c(extraOrbits, list(extraOutsideOrbits))
      }
      vOrbits = curGraphOrb$orbitsV
      extraInsideOutsideOrbits = lapply(vOrbits, function(x) { as.vector(as.matrix(expand.grid(x, extraVerts))) })
      extraOrbits = c(extraOrbits, extraInsideOutsideOrbits)
    }
    extraOrbits = lapply(extraOrbits, function(x) { auxMatrix[matrix(x, ncol = 2)]} )
    extraOrbits = extraOrbits[sapply(extraOrbits, length) > 1]
    if (length(extraOrbits) > 0) {
      numExtraConst = sum(sapply(extraOrbits, length)) - length(extraOrbits)
      extraIndices = lapply(extraOrbits, function(x) { y = rep(x, each = 2); y = y[-c(1, length(y))]; y })
      cplexAPI::addRowsCPLEX(envir, model, ncols = 0, nrows = numExtraConst, nnz = 2 * numExtraConst, sense = rep("E", numExtraConst), rhs = rep(0, numExtraConst),
                           matbeg = 2 * (0:(numExtraConst - 1)), matind = match(unlist(extraIndices), redCNames) - 1, matval = rep(c(1,-1), numExtraConst))
    }
    ### cplexAPI::writeProbCPLEX(envir, model, fname = fname)
    cplexAPI::dualoptCPLEX(envir, model)
    curSolution = cplexAPI::solutionCPLEX(envir, model)
    if (curSolution$lpstat == cplexAPI::CPX_STAT_OPTIMAL) {
      curObjL = curSolution$objval
      boundL  = as.integer(ifelse(near(curObjL, round(curObjL)), round(curObjL), ceiling(curObjL)))
      if (boundL > prevLowerBound) {
        curDualsL  = curSolution$pi
        if (!(all(near(curDualsL, 0)))) {
          proofL   = constructProof(prep, curDualsL[1:numConst], lower = TRUE, shortProofs = shortProofs)
        }
      }
    }
    if (!is.na(eps)) {
      cplexAPI::setDblParmCPLEX(envir, cplexAPI::CPXPARAM_Simplex_Limits_LowerObj, 0)
    }
    if (symRS) {
      boundU = curSize - boundL
      proofU = proofL
    } else {
      if (!lowerOnly) {
        cplexAPI::setObjDirCPLEX(envir, model, CPX_MAX)
        if (!is.na(eps)) {
          cplexAPI::setDblParmCPLEX(envir, cplexAPI::CPXPARAM_Simplex_Limits_UpperObj, prevUpperBound - eps)
        }
        cplexAPI::dualoptCPLEX(envir, model)
        altSolution = cplexAPI::solutionCPLEX(envir, model)
        if (curSolution$lpstat == cplexAPI::CPX_STAT_OPTIMAL) {
          curObjU = altSolution$objval
          boundU  = as.integer(ifelse(near(curObjU, round(curObjU)), round(curObjU), floor(curObjU)))
          if (boundU < prevUpperBound) {
            curDualsU  = altSolution$pi
            if (!(all(near(curDualsU, 0)))) {
              proofU   = constructProof(prep, curDualsU[1:numConst], lower = FALSE, shortProofs = shortProofs)
            }
          }
        }
        if (!is.na(eps)) {
          cplexAPI::setDblParmCPLEX(envir, cplexAPI::CPXPARAM_Simplex_Limits_UpperObj, curSize)
        }
        cplexAPI::setObjDirCPLEX(envir, model, CPX_MIN)
      }
    }
    if (numExtraConst > 0) {
      cplexAPI::delRowsCPLEX(envir, model, numConst, numConst + numExtraConst - 1)
    }
    if (!is.null(proofL) || !is.null(proofU)) {
      curResult = list(graph = curIndex, proofL = proofL, proofU = proofU, boundL = boundL, boundU = boundU)
    }
    output[[ind]] = curResult
  }
  cplexAPI::delProbCPLEX(envir, model)
  cplexAPI::closeEnvCPLEX(envir)
  finalOutput = list(output = output, adj = prep$adj, orb = allGraphOrb)
  finalOutput
}

### This function constructs optimised proofs from the outputs of iterateLPProof
### If eps is non-NA, the 1 (-1) increment in objective value is replaced by eps.
### The objective is to identify proofs with a minimal number of dual variables.
optimiseProofs = function(output, eps = NA) {
  allContradictions = output[[4]]
  allGraphs = output[[3]]
  L = length(allGraphs)
  allGraphAdj = vector("list", L)
  allGraphOrb = vector("list", L)
  r = invertNumPairs(allContradictions[[1]]$size[1])
  s = invertNumPairs(allContradictions[[1]]$size[2])
  bestProof = prepareBestProof(allContradictions, allGraphs, r = r, s = s, fname = NULL, plotGraphs = TRUE) %>%
    mutate(subsumed = FALSE)
  M = nrow(bestProof)
  allProofs = vector("list", M)
  pos = 3
  maxIter = max(bestProof$step)
  numAutos = sapply(allGraphs, function(x) { as.integer(automorphisms(makeIgraph(x))$group_size) })
  graphTab = tibble(index = 1:L, size = sapply(allGraphs, length)/2, order = sapply(allGraphs, max), n_auto = numAutos, n_embed = factorial(order)/n_auto)
  for (ind in 2:maxIter) {
    prevBounds = bestProof %>%
      filter(step < ind) %>%
      group_by(graph, direction) %>%
      filter(step == max(step)) %>%
      ungroup()
    curBounds = bestProof %>%
      filter(step == ind)
    curSupport = curBounds$support[1]
    auxMatrix = createPositionMatrix(curSupport, symmetric = TRUE)
    prep = prepareRamseyLP(numVertices = curSupport, allGraphs = allGraphs, allGraphAdj = allGraphAdj, allGraphOrb = allGraphOrb, graphBounds = prevBounds, 
                           graphInfo = graphTab, sparse = TRUE)
    numVars  = ncol(prep$mat)
    numConst = length(prep$dir)
    numNonZeros = tail(prep$mat@p,1)
    CN = paste0("X", 1:numVars)
    initObjective = rep(0, numVars)
    envir = cplexAPI::openEnvCPLEX()
    model = cplexAPI::initProbCPLEX(envir, pname = "Ramsey Bound Optimisation")
    dualModel = cplexAPI::initProbCPLEX(envir, pname = "Ramsey Proof Optimisation")
    cplexAPI::copyLpwNamesCPLEX(env = envir, lp = model, nCols = numVars, nRows = numConst, lpdir = CPX_MIN, objf = rep(0, numVars), rhs = prep$rhs, sense = prep$dir, 
    matbeg = prep$mat@p[1:numVars], matcnt = diff(prep$mat@p), matind = prep$mat@i, matval = rep(1, numNonZeros), lb = rep(0, numVars), ub = rep(1, numVars), cnames = CN)
    fname  = paste0("ProofR", r, "S", s, "I", ind, ".lp")
    # cplexAPI::writeProbCPLEX(envir, model, fname = fname)
    cplexAPI::setIntParmCPLEX(envir, cplexAPI::CPXPARAM_Preprocessing_Presolve, 0)
    numBounds = nrow(curBounds)
    numVerts = invertNumPairs(numVars)
    allPairs = combn2(1:numVerts)
    for (index in 1:numBounds) {
      curBound = curBounds %>% slice(index)
      curIndex = curBound$graph
      curGraph = allGraphs[[curIndex]]
      curEdges = auxMatrix[matrix(curGraph, ncol = 2)]
      curSense = curBound$direction
      curTarget = curBound$bound
      redCNames = cplexAPI::getColNameCPLEX(envir, model, 0, numVars - 1) %>% 
        str_remove_all("X") %>% 
        as.integer()
      curObjective = initObjective
      curObjective[match(curEdges, redCNames)] = 1
      cplexAPI::chgObjCPLEX(envir, model, ncols = numVars, ind = 0:(numVars - 1), val = curObjective)
      cplexAPI::setObjDirCPLEX(envir, model, ifelse(curSense == "G", CPX_MIN, CPX_MAX))
      if (is.na(eps)) {
        cplexAPI::dualoptCPLEX(envir, model)
        origObj = cplexAPI::solutionCPLEX(envir, model)$objval
      }
      dualMPSFile = str_replace(fname, ".lp", "Dual.mps")
      dualWriteCPLEX(envir, model, fname = dualMPSFile)
      cplexAPI::readCopyProbCPLEX(envir, dualModel, fname = dualMPSFile)
      # cplexAPI::writeProbCPLEX(envir, dualModel, fname = str_replace(dualMPSFile, ".mps", ".lp"))
      extConst = cplexAPI::getNumColsCPLEX(envir, dualModel)
      stopifnot(extConst == numConst + numVars)
      newBound = ifelse(!is.na(eps), curTarget + ifelse(curSense == "G", -1, 1) * (1 - eps), origObj)
      origDualObj = cplexAPI::getObjCPLEX(envir, dualModel, 0, extConst - 1) * ifelse(curSense == "G", -1, 1)
      cplexAPI::addRowsCPLEX(envir, dualModel, nrows = 1, nnz = extConst, rhs = newBound, sense = ifelse(is.na(eps), curSense, "E"),
                             matbeg = 0, matind = 0:(extConst - 1), matval = origDualObj, ncols = 0, rnames = paste0("D", 0))
      newRange = rbind(1:extConst, extConst + (1:extConst), 1:extConst, extConst + (1:extConst))
      cplexAPI::newColsCPLEX(envir, dualModel, ncols = extConst, lb = rep(0, extConst), xctype = rep(cplexAPI::CPX_CONTINUOUS, extConst), cnames = c(paste0("Y", 1:numConst), paste0("Z", 1:numVars)))
      cplexAPI::addRowsCPLEX(envir, dualModel, nrows = 2 * extConst, nnz = 4 * extConst, rhs = rep(0, 2 * extConst), sense = rep("G", 2 * extConst), 
      matbeg = 2 * (0:(2 * extConst - 1)), matind = as.vector(newRange) - 1, matval = rep(c(-1, 1, 1, 1), extConst), ncols = 0, rnames = paste0("D", 1:(2 * extConst)))
      dualCNames = cplexAPI::getColNameCPLEX(envir, dualModel, 0, 2 * extConst - 1)
      newDualObj = rep(0, 2 * extConst)
      newDualObj[str_starts(dualCNames, "Y")] = 1 
      cplexAPI::chgObjCPLEX(envir, dualModel, ncols = 2 * extConst, ind = 0:(2 * extConst - 1), val = newDualObj)
      # cplexAPI::writeProbCPLEX(envir, dualModel, fname = str_replace(dualMPSFile, ".mps", ".lp"))
      cplexAPI::chgProbTypeCPLEX(envir, dualModel, ptype = cplexAPI::CPXPROB_LP)
      cplexAPI::primoptCPLEX(envir, dualModel)
      dualSolution = cplexAPI::solutionCPLEX(envir, dualModel)$x[1:numConst]
      sharpProof = constructProof(prep, dualSolution, lower = (curSense == "G"), shortProofs = FALSE)
      colnames(sharpProof) = c("coeff", paste0("X", allPairs[,1], ",", allPairs[,2]), "rhs", "bound")
      prevBounds %<>%
        select(number, label)
      sharpProof %<>%
        as_tibble() %>%
        left_join(prevBounds, by = join_by(bound == number))
      allProofs[[pos]] = sharpProof
      pos = pos + 1
    }
    cplexAPI::delProbCPLEX(envir, model)
    cplexAPI::delProbCPLEX(envir, dualModel)
    cplexAPI::closeEnvCPLEX(envir)
  }
  output = list(bestProof = bestProof, allProofs = allProofs)
  output
}

### This function traces the chain of proofs based on the LPs in a given directory
### The other inputs are r, s and n for which we are proving that Ramsey(r, s) >= n
### It returns the list of graphs used (0-padded matrix, one graph per row), the
### list of bounds (if simplifyBounds, it contains each bound's first occurrence), 
### and additional graph information: order, size and the number of automorphisms.
forensicTrace = function(Dir = "LPFilesForR3S4Auto6LowerOnly", r = 3, s = 3, n = 6, baseFilename = paste0("TempFileR", r, "S", s, "I"), simplifyBounds = FALSE) {
  initDir = getwd()
  setwd(Dir)
  LF = list.files(pattern = baseFilename)
  nC2 = choose(n, 2)
  allGraphs = matrix(NA, nrow = 0, ncol = nC2 * 2)
  graphPos = 1L
  boundTab = tibble()
  infoTab = tibble()
  envir = cplexAPI::openEnvCPLEX()
  model = cplexAPI::initProbCPLEX(envir, pname = "Ramsey Polytope")
  L = length(LF)
  print(paste("There are", L, "iterations to process"))
  curCount = 1L
  for (iter in 1:L) {
    curFile = paste0(baseFilename, iter, ".lp")
    cplexAPI::readCopyProbCPLEX(envir, model, fname = curFile)
    numVars = cplexAPI::getNumColsCPLEX(envir, model)
    numVerts = invertNumPairs(numVars)
    print(paste("Currently processing iteration", iter, "with", numVerts, "vertices in the support"))
    auxMatrix = createPositionMatrix(numVerts, symmetric = FALSE)
    curNames = cplexAPI::getColNameCPLEX(envir, model, 0, numVars - 1) %>%
      str_remove("X") %>%
      as.integer()
    curTotal = 0
    numConst = cplexAPI::getNumRowsCPLEX(envir, model)
    while (curTotal < numConst) {
      curRow = curNames[cplexAPI::getRowsCPLEX(envir, model, curTotal, curTotal)$matind + 1]
      curDir = cplexAPI::getSenseCPLEX(envir, model, curTotal, curTotal)
      curRhs = cplexAPI::getRhsCPLEX(envir, model, curTotal, curTotal)
      curGraph = which(matrix(auxMatrix %in% curRow, nrow = numVerts), arr.ind = TRUE) %>%
        as_tibble() %>%
        arrange(row, col) %>%
        as.matrix()
      allGraphs = rbind(allGraphs, as.vector(fillWithZeros(curGraph, nC2)))
      prevPos = which(duplicated(allGraphs, fromLast = TRUE))
      if (length(prevPos) == 0) {
        prevPos = graphPos
        curNumAutos = as.integer(automorphisms(makeIgraph(curGraph))$group_size)
        curInfo = tibble(graph = graphPos, order = max(curGraph), size = nrow(curGraph), n_auto = curNumAutos)
        infoTab %<>% bind_rows(curInfo)
        graphPos = graphPos + 1L
      } else {
        allGraphs = allGraphs[1:(graphPos - 1), , drop = FALSE] 
        curInfo = infoTab %>% slice(prevPos)
      }
      boundTab %<>% bind_rows(tibble(graph = prevPos, direction = curDir, bound = curRhs, round = iter, support = numVerts, number = curCount))
      curCount = curCount + 1L
      doubled = FALSE
      if (curTotal + 1 < numConst) {
        nextRow = curNames[cplexAPI::getRowsCPLEX(envir, model, curTotal + 1, curTotal + 1)$matind + 1]
        if (all(curRow == nextRow)) {
          doubled = TRUE
          nextDir = cplexAPI::getSenseCPLEX(envir, model, curTotal + 1, curTotal + 1)
          nextRhs = cplexAPI::getRhsCPLEX(envir, model, curTotal + 1, curTotal + 1)
          boundTab %<>% bind_rows(tibble(graph = prevPos, direction = nextDir, bound = nextRhs, round = iter, support = numVerts, number = curCount))
          curCount = curCount + 1L
        }
      }
      curNumConst = (factorial(numVerts) / (factorial(numVerts - curInfo$order) * curInfo$n_auto)) * (1 + doubled)
      curTotal = curTotal + curNumConst
    }
  }
  allGraphs = allGraphs[1:(graphPos - 1), , drop = FALSE]
  boundTab %<>%
    mutate(subsumed = FALSE, size = infoTab$size[graph])
  if (simplifyBounds) {
    boundTab = boundTab %>%
      group_by(graph, direction, bound) %>%
      filter(iter == min(iter)) %>%
      ungroup
  }
  setwd(initDir)
  output = list(allGraphs = allGraphs, boundTab = boundTab, graphInfo = infoTab)
  output
}
